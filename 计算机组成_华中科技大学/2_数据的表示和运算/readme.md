# 数据的表示和运算 重要知识点

## 一、运算方法和运算电路

### ALU 算术逻辑单元

- ALU是一种功能较强的组合逻辑电路，能进行多种算术运算和逻辑运算。

1. ZF：若ZF为1，则表示运算结果为0。
2. OF：若OF为1，则表示带符号整数运算发生溢出。
3. SF：表示结果的符号。
4. CF：表示无符号整数运算的进位/借位。CF=1时，表示加法有进位或减法有借位。

- 判断溢出的规则为
  - 若加法器的两个输入端的符号相同，且不同于输出端的符号的符号，则结果溢出。（适用于有符号数）
  - 加法器完成加法操作时，若最高数位的进位和符号位的进位不同不同，则结果溢出。（通用）
  - 双符号位。00表示结果为正无溢出；01表示结果正溢出；10表示结果负溢出；11表示结果为负，无溢出。

### 补码一位乘法（Booth算法）

- 设[X]补=Xs.X1X2...Xn，[Y]补=Ys.Y1Y2...Yn，则运算规则表示如下：

1. 符号位参与运算，运算的数均以补码表示。
2. 被乘数一般取双符号位参与运算，部分积取双符号位，初值为0，乘数取单符号位。
3. 乘数末位增设附加位Yn+1，初值为0。
4. 根据(Yn,Yn+1)的取值来确定操作。
   - (0,0)：部分积右移一位
   - (0,1)：部分积加[X]补，右移一位
   - (1,0)：部分积加[-X]补，右移一位
   - (1,1)：部分积右移一位。
5. 移位按补码右移规则进行。
6. 按照上述操作进行n+1步操作，单第n+1步不在位移（共进行n+1次累加和n次右移），仅根据Yn与Yn+1的比较结果做相应的运算。

### 原码不恢复余数法除法

- 原码不恢复余数法爷成原码加减交替除法。特点是商符和商值是分开进行的，减法操作用补码加法实现，商符由两个操作数的符号位“异或”形成。
- 设被除数[X]原=Xs.X1X2...X3，除数[Y]原=Ys.Y1Y2...Yn，则求商值的规则如下：

1. 商的符号：Qs=Xs异或Ys
2. 商的数值：|Q|=|X|/|Y|
3. 先用被除数减去除数(|X|-|Y|=|X|+(-|Y|)=|X|+[-Y]补)，当余数为正项时，商上1，余数和商左移一位，再减去除数；当余数为负时，商上0，余数和商左移一位，再加上余数。
4. 当第n+1步余数为负时，需加上|Y|得到第n+1步正确的余数（余数与被除数同号）。

### 大端存储与小端存储

- 大端：即大尾端，数据的低位放在地址的高位。
- 小端：即小尾端，数据的低位放在地址的低位。

### 边界对齐

- 32位机器，半字地址一定是2的整数倍，子地址一定是4的整数倍。
- 边界对齐虽然浪费了一些存储空间，但可提高指令和取数的速度。

## 二、浮点数的表示和运算

### 浮点数的表示与规格化

- 浮点数由 数符S+阶码E+尾数M 三部分组成。

> 例如，第0位为数符S；第1~7位为移码表示的阶码E(偏置值为64)；第8~31位为24位二进制码小数表示的尾数M；基数R为2。

- 规格化：通过调整一个非规格化浮点数的尾数和阶码大小，使非零的浮点数在尾数的最高数位上保证是一个有效值。
- 左规：尾数出现0.0...01X...时，需要左规。左规时，尾数每左移一位、阶码减1。左规可能要进行很多次。
- 右规：当预算结果的尾数的有效位进到小数点前面时，需要进行右规。将尾数右移一位、阶码加1.需要右规时，只需进行一次。

> 规格化浮点数的尾数M的绝对值应满足1/2<=|M|<1。若尾数有n位，则尾数的表示范围为1/2<=|M|<=(1-2^n)。

### IEEE754标准的浮点数

- 短浮点数(float) 32位=1位数符+8位阶码+23位尾数。阶码偏置值为127。
- 长浮点数(double) 64位=1位数符+11位阶码+52位尾数。阶码偏置值为1023。
- 注意，在IEEE754标准中，由于规格化的二进制浮点数，数值的最高位总是“1”，为使尾数能多表示一位有效位，将这个“1”隐藏，称为 隐藏位。
- 对于短浮点数，阶码E的取值为1~254。同理，长浮点数1~2046。
- IEEE754短浮点数 在阶码E=1，尾数M=0时绝对值最小=1.0×2^(1-127)=2^-126
- IEEE754短浮点数 在阶码E=254(除了末位均取1)，尾数=1.11...1(小数点后23个1) 时绝对值最大=2^127×(2-2^-23)

> 对于IEEE754的浮点数，阶码全0或全1时，尤其特别的解：  
> 阶码全0，尾数全0时，表示浮点数为0，+0与-0等价。  
> 阶码全1，尾数全0时，表示浮点数为±∞，符号取决于数符。  
> 其他阶码全0或全1的情况为非规格化浮点数，不在考试范围内。

### 浮点数的加减运算

1. 对阶
   - 为使两个操作数的小数点对齐，先求阶差，再将阶码小的浮点数右移一位、阶码加1，直至阶码相等。
2. 尾数求和
   - 将对阶后的尾数按定点数加减运算规则运算。
3. 规格化
   - 当尾数求和结果为±1X.XXX时，需要进行右规。尾数右移一位，阶码加1。最后一位移出时，要考虑舍入。
   - 当尾数求和结果为±0.00...01X..时，需要进行左规。尾数每左移一位，阶码减一。可能要左规多次。
4. 舍入
   - 规格化进行右移后，为确保运算精度，一般将低位溢出的两位留下来，参加中间过程的运算，最后将结果舍入，还原表示成IEEE754格式。
   - 0舍1入法：丢1则尾数末位加1。若导致尾数溢出，则继续右规。
   - 恒置1法：不论丢掉的最高数位是0还是1，都把右移后的尾数末位恒置1。
   - 截断法：不舍入，直接丢弃。
5. 溢出判断
   - 若指数超过了最大允许值则发生上溢，产生异常。
   - 若指数低于了最小允许值则发生下溢，通常把运算结果置0。
